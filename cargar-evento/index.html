<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Carga r√°pida de evento</title>
    <link rel="stylesheet" href="/base.css" />
  </head>
  <body>
    <h1>Carga de evento r√°pida ‚ö°</h1>
    <form action="" method="post" enctype="multipart/form-data">
      <div id="imagesPreview"></div>
      <input id="files" type="file" accept="image/*" multiple name="images" />
      <div id="filesBase64" hidden>
        <!-- Dynamically added <input type="hidden"> elements for sending images in base64 format, needed for x-www form encoding -->
      </div>
      <label for="text">Descripci√≥n</label>
      <textarea id="description" name="description" rows="10"></textarea>

      <button type="submit">Publicar</button>
    </form>
    <style>
      form {
        display: grid;
        gap: 1rem;
        padding: 1rem;
        max-width: 45ch;
        margin-inline: auto;
      }

      h1 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        text-align: center;
      }

      #imagesPreview {
        display: flex;
        overflow-x: scroll;
        width: 100%;
        scroll-behavior: auto;
        scroll-snap-type: x mandatory;

        & img {
          max-width: 100%;
          object-fit: contain;
          scroll-snap-align: start;
        }
      }
    </style>
    <script type="module">
      const form = document.querySelector("form");

      const api = `https://script.google.com/macros/s/AKfycbx-aF03sO-JizuijiMY1tu5v0GXhzH08GUtkUy0tegwzB8LLQ-VwzD7YEQ-vK1YEcK_/exec`;
      const query = `?endpoint=uploadEvent`;
      let action = `${api}${query}`;

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const submitButton = document.querySelector("button[type=submit]");

        const buttonText = submitButton.textContent;
        const formData = new FormData(form);

        // Check if the form has any files
        const files = formData.getAll("images").filter((f) => f instanceof File && f.size > 0);
        // check if at least one image exists

        if (files.length === 0) {
          alert("Al menos una imagen requerida.");
          return;
        }

        submitButton.disabled = true;
        submitButton.textContent = "Publicando...";

        try {
          const eventData = await submitFormData(formData);
          submitButton.textContent = "Evento cargado! üëå";
          console.log("response:", eventData);
          console.log(`redirect to event page ${window.location.origin}/${eventData.slug}`);
          form.reset();
          // Event uploaded or found succesfully
          const cache = await caches.open(SHARE_TARGET_ACTION);
          for (const key of await cache.keys()) {
            console.info(`Deleting cache entry: ${key.url}`);
            await cache.delete(key);
          }
          // Redirect to the event page
          window.location.href = `${window.location.origin}/${eventData.slug}`;
        } catch (error) {
          console.error("Error processing response:", error);
          alert(`Error procesando el evento: ${error.message}`);
        }

        submitButton.disabled = false;
        submitButton.textContent = buttonText;
      });

      async function filesToBase64(files) {
        const filePromises = [];
        for (const file of files) {
          if (!file || !(file instanceof File)) {
            console.warn("Skipping non-file input:", file);
            continue;
          }
          // Compress the image before converting to base64
          const promise = compressImage(file).then((compressedFile) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (event) => {
                const base64 = event.target.result.split(",")[1];
                resolve({
                  name: compressedFile.name,
                  mimeType: compressedFile.type,
                  base64,
                });
              };
              reader.onerror = reject;
              reader.readAsDataURL(compressedFile);
            });
          });
          filePromises.push(promise);
        }
        return await Promise.all(filePromises);
      }

      /**
       * Compresses an image file to a specified maximum width and quality.
       * @param {File} file - The image file to compress.
       * @param {number} maxWidth - The maximum width of the compressed image.
       * @param {number} quality - The quality of the compressed image (0 to 1).
       * @returns {Promise<File>} - A promise that resolves to the compressed image file.
       */
      function compressImage(file, maxWidth = 1000, quality = 0.7) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // Calculate the new dimensions
            let width = img.width;
            let height = img.height;
            if (width > maxWidth) {
              height *= maxWidth / width;
              width = maxWidth;
            }

            canvas.width = width;
            canvas.height = height;

            // Draw the image on the canvas
            ctx.drawImage(img, 0, 0, width, height);

            // Convert the canvas to a Blob
            canvas.toBlob(
              (blob) => {
                resolve(new File([blob], file.name, { type: file.type }));
              },
              file.type,
              quality
            );
          };
          img.onerror = reject;
          img.src = URL.createObjectURL(file);
        });
      }

      async function submitFormData(formData) {
        const body = {
          description: formData.get("description"),
          files: [],
        };

        body.files = await filesToBase64(formData.getAll("images"));
        const response = await fetch(action, {
          method: "POST",
          redirect: "follow",
          headers: {
            "Content-Type": "text/plain;charset=UTF-8", // Use text/plain to avoid OPTION -> CORS issues
          },
          body: JSON.stringify(body),
        });

        return await extractSuccessResponse(response);
      }
    </script>

    <script>
      async function extractSuccessResponse(response) {
        if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
        const jsonResponse = await response.json();
        if (!jsonResponse.success) throw new Error(jsonResponse.message);
        return jsonResponse.data;
      }

      const SHARE_TARGET_ACTION = "/share-target"; // Also used as the cache key for the shared data
      // Cache hydration handling
      async function hydrateWithCachedData() {
        const cache = await caches.open(SHARE_TARGET_ACTION);

        // Hydrate texts
        for (const input of document.querySelectorAll("input:not([type=file]), textarea")) {
          const key = input.name;
          const response = await cache.match(`/${key}`);

          if (!response || !response.ok) {
            console.info(`Cache miss for key ${key}`);
            continue;
          }
          const contentType = response.headers.get("content-type");
          if (!contentType?.includes("text")) {
            console.warn(`Content type mismatch for key ${key}: expected text but got ${contentType}`);
            continue;
          }
          console.info(`Hydrating ${key} from cache`);
          input.value = await response.text();
        }

        // Hydrate files
        const fileBlobs = await getCachedFileBlobs();
        const dataTransfer = new DataTransfer();
        for (const fileBlob of fileBlobs) {
          const file = new File([fileBlob], `/file-${fileBlobs.indexOf(fileBlob)}`, {
            type: fileBlob.type,
          });
          dataTransfer.items.add(file);
        }
        files.files = dataTransfer.files;

        if (files.files.length > 0) {
          await prepareBase64Images();
        }
      }

      // Load cached files and create preview images
      async function getCachedFileBlobs() {
        const cache = await caches.open(SHARE_TARGET_ACTION);
        const fileBlobs = [];

        do {
          const response = await cache.match(`/file-${fileBlobs.length}`);
          if (response) {
            console.log(`found /file-${fileBlobs.length}`, response);
            fileBlobs.push(await response.blob());
            continue;
          }
          break;
        } while (true);

        return fileBlobs;
      }

      async function fileToDataURI(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const dataURI = reader.result;
            resolve(dataURI);
          };
          reader.onerror = (error) => reject(error);
          reader.readAsDataURL(file);
        });
      }

      /**
       * Prepare files by creating a preview images and populating inputs with their base64 versions.
       */
      async function prepareBase64Images({ addFilesAsSeperateInputsWithDataUri = false } = {}) {
        // Flush
        filesBase64.innerHTML = "";
        for (const img of imagesPreview.children) {
          URL.revokeObjectURL(img.src); // Must revoke existing images first
        }
        imagesPreview.innerHTML = "";
        // Populate
        for (let i = 0; i < files.files.length; ++i) {
          const file = files.files[i];
          // Add preview
          const img = document.createElement("img");
          img.src = URL.createObjectURL(file);
          imagesPreview.appendChild(img);

          if (addFilesAsSeperateInputsWithDataUri) {
            const input = document.createElement("input");
            input.type = "hidden";
            input.name = `files`; // x-www-form-urlencoded will send duplicate keys as an array.
            input.value = await fileToDataURI(file);
            filesBase64.appendChild(input);
          }
        }
      }

      files.addEventListener("change", async () => {
        const cache = await caches.open(SHARE_TARGET_ACTION);
        // Clear previous cache entries
        for (let i = 0; ; ++i) {
          const response = await cache.match(`/file-${i}`);
          if (!response) {
            break;
          }
          await cache.delete(`/file-${i}`);
        }
        prepareBase64Images();
        // Cache files
        let filesCount = 0;
        for (const file of files.files) {
          await cache.put(`/file-${filesCount}`, new Response(file));
          ++filesCount;
        }
      });

      hydrateWithCachedData();
    </script>
  </body>
</html>
